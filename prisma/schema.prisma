generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Merchant {
  id         Int           @id @default(autoincrement())
  fee        Decimal       @default(6.50) @db.Decimal(4, 2)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  companyId  BigInt
  company    Company       @relation(fields: [companyId], references: [id])
  Customers  Customer[]
  Compliance Compliance[]
  Orders     Transaction[]
  Employees  Employee[]
  User       User[]
}

model Customer {
  id             BigInt           @id @default(autoincrement())
  name           String           @db.VarChar(255)
  surname        String?          @db.VarChar(255)
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  merchantId     Int
  addressId      BigInt?
  userId         BigInt           @unique
  user           User             @relation(fields: [userId], references: [id])
  billingAddress PhysicalAddress? @relation(fields: [addressId], references: [id])
  merchant       Merchant         @relation(fields: [merchantId], references: [id])
  compliance     Compliance[]
  orders         Transaction[]
}

model Compliance {
  id                       String             @id @default(uuid()) @db.Uuid
  type                     AccountType
  verificationDocumentLink String             @unique
  termsOfServiceLink       String             @unique
  verificationStatus       VerificationStatus @default(NOT_STARTED)
  termsOfServiceStatus     TosStatus          @default(PENDING)
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt
  buyerId                  BigInt?
  merchantId               Int?
  customer                 Customer?          @relation(fields: [buyerId], references: [id])
  merchant                 Merchant?          @relation(fields: [merchantId], references: [id])
}

model Transaction {
  id               String            @id @default(uuid())
  status           TransactionStatus
  partnerTokenId   String
  partnerRequestId String
  currency         String            @db.Char(3)
  amount           BigInt
  tip              Decimal?          @default(0.00) @db.Decimal(4, 2)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  buyerId          BigInt
  merchantId       Int
  addressId        BigInt?
  shippingAddress  PhysicalAddress?  @relation(fields: [addressId], references: [id])
  customer         Customer          @relation(fields: [buyerId], references: [id])
  merchant         Merchant          @relation(fields: [merchantId], references: [id])
}

model PhysicalAddress {
  id          BigInt        @id @default(autoincrement())
  street1     String        @db.VarChar(50)
  street2     String?       @db.VarChar(50)
  city        String        @db.VarChar(50)
  postcode    String?       @db.VarChar(25)
  state       String?       @db.Char(2)
  country     String        @db.Char(2)
  type        AddressType
  Customer    Customer[]
  Transaction Transaction[]
  Company     Company[]
}

model RegisteredPasskey {
  id           Int                 @id @default(autoincrement())
  name         String?             @db.VarChar(255)
  credentialId String              @unique
  publicKey    String
  algorithm    CredentialAlgorithm @default(ES256)
  userId       BigInt
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  user         User                @relation(fields: [userId], references: [id])
}

model Employee {
  id         Int          @id @default(autoincrement())
  name       String       @db.VarChar(255)
  surname    String       @db.VarChar(255)
  role       EmployeeRole
  merchantId Int
  userId     BigInt
  rainId     String?      @unique @db.VarChar(36)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  user       User         @relation(fields: [userId], references: [id])
  merchant   Merchant     @relation(fields: [merchantId], references: [id])
}

model User {
  id                 BigInt              @id @default(autoincrement())
  email              String              @unique
  phoneNumber        String?             @unique
  walletAddress      String?             @unique
  username           String?             @unique @db.VarChar(15)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  registeredPasskeys RegisteredPasskey[]
  merchantProfile    Merchant?           @relation(fields: [merchantId], references: [id])
  customerProfile    Customer?
  apiKeys            ApiKey[]
  employees          Employee[]
  merchantId         Int?
}

model ApiKey {
  id         String    @id @default(uuid())
  key        String    @unique
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?
  expiresAt  DateTime?
  isActive   Boolean   @default(true)
  userId     BigInt
  user       User      @relation(fields: [userId], references: [id])

  @@index([key])
}

model Company {
  id                BigInt          @id @default(autoincrement())
  name              String          @unique @db.VarChar(255)
  number            String          @unique @db.VarChar(255)
  repName           String          @db.VarChar(255)
  repSurname        String          @db.VarChar(255)
  email             String          @unique @db.VarChar(255)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  addressId         BigInt
  registeredAddress PhysicalAddress @relation(fields: [addressId], references: [id])
  Merchant          Merchant[]
}

enum TransactionStatus {
  PENDING
  COMPLETE
  FAILED
  ERROR
}

enum AddressType {
  BILLING
  SHIPPING
  REGISTERED
}

enum VerificationStatus {
  NOT_STARTED
  PENDING
  INCOMPLETE
  AWAITING_UBO
  MANUAL_REVIEW
  UNDER_REVIEW
  APPROVED
  REJECTED
}

enum TosStatus {
  PENDING
  APPROVED
}

enum AccountType {
  BUSINESS
  INDIVIDUAL
}

enum CredentialAlgorithm {
  RS256
  ES256
}

enum EmployeeRole {
  OWNER
  BOOKKEEPER
  DEVELOPER
}
